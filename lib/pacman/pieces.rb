# ğŸ˜€ ğŸ˜ ğŸ˜‚ ğŸ˜ƒ ğŸ˜„ ğŸ˜… ğŸ˜† ğŸ˜‡ ğŸ˜ˆ ğŸ‘¿ ğŸ˜‰ ğŸ˜Š â˜ºï¸ ğŸ˜‹ ğŸ˜Œ ğŸ˜ ğŸ˜ ğŸ˜ ğŸ˜ ğŸ˜‘ ğŸ˜’ ğŸ˜“ ğŸ˜” ğŸ˜• ğŸ˜– ğŸ˜— ğŸ˜˜ ğŸ˜™ ğŸ˜š
# ğŸ˜› ğŸ˜œ ğŸ˜ ğŸ˜ ğŸ˜Ÿ ğŸ˜  ğŸ˜¡ ğŸ˜¢ ğŸ˜£ ğŸ˜¤ ğŸ˜¥ ğŸ˜¦ ğŸ˜§ ğŸ˜¨ ğŸ˜© ğŸ˜ª ğŸ˜« ğŸ˜¬ ğŸ˜­ ğŸ˜® ğŸ˜¯ ğŸ˜° ğŸ˜± ğŸ˜² ğŸ˜³ ğŸ˜´ ğŸ˜µ ğŸ˜¶ ğŸ˜·
# ğŸ˜¸ ğŸ˜¹ ğŸ˜º ğŸ˜» ğŸ˜¼ ğŸ˜½ ğŸ˜¾ ğŸ˜¿ ğŸ™€ ğŸ‘£ ğŸ‘¤ ğŸ‘¥ ğŸ‘» ğŸ‘¹ ğŸ‘º ğŸ’© ğŸ’€ ğŸ‘½ ğŸ‘¾
#
# ğŸ… ğŸ† ğŸŒ½ ğŸ  ğŸ‡ ğŸˆ ğŸ‰ ğŸŠ ğŸ‹ ğŸŒ ğŸ ğŸ ğŸ ğŸ ğŸ‘ ğŸ’ ğŸ“ ğŸ” ğŸ• ğŸ– ğŸ— ğŸ˜ ğŸ™ ğŸš ğŸ› ğŸœ ğŸ ğŸ ğŸŸ
# ğŸ¡ ğŸ¢ ğŸ£ ğŸ¤ ğŸ¥ ğŸ¦ ğŸ§ ğŸ¨ ğŸ© ğŸª ğŸ« ğŸ¬ ğŸ­ ğŸ® ğŸ¯ ğŸ° ğŸ± ğŸ² ğŸ³ ğŸ´ ğŸµ â˜•ï¸ ğŸ¶ ğŸ· ğŸ¸ ğŸ¹ ğŸº ğŸ» ğŸ¼
#
# ğŸ€ ğŸ ğŸ‚ ğŸƒ ğŸ„ ğŸ‹ ğŸ ğŸ‘ ğŸ† ğŸ‡ ğŸ‰ ğŸŠ ğŸˆ ğŸ’« âœ¨ ğŸ’¥ ğŸ“ ğŸ‘‘ ğŸ ğŸ ğŸ ğŸŒ ğŸ® ğŸ’
#
# â¤ï¸ ğŸ’” ğŸ’Œ ğŸ’• ğŸ’ ğŸ’“ ğŸ’— ğŸ’– ğŸ’˜ ğŸ’ ğŸ’Ÿ ğŸ’œ ğŸ’› ğŸ’š ğŸ’™
#
# âš¡ï¸ ğŸ”¥ ğŸŒ™ â˜€ï¸ â›…ï¸ â˜ï¸ ğŸ’§ ğŸ’¦ â˜”ï¸ ğŸ’¨ â„ï¸ ğŸŒŸ â­ï¸ ğŸŒ  ğŸŒ„ ğŸŒ… ğŸŒˆ ğŸŒŠ ğŸŒ‹ ğŸŒŒ ğŸ—» ğŸ—¾
#
# ğŸŒ ğŸŒ ğŸŒ ğŸŒ ğŸŒ‘ ğŸŒ’ ğŸŒ“ ğŸŒ” ğŸŒ• ğŸŒ– ğŸŒ— ğŸŒ˜ ğŸŒš ğŸŒ ğŸŒ› ğŸŒœ ğŸŒ
#
# ğŸ€ ğŸ ğŸ­ ğŸ¹ ğŸ‚ ğŸƒ ğŸ„ ğŸ® ğŸ… ğŸ† ğŸ¯ ğŸ‡ ğŸ° ğŸˆ ğŸ± ğŸ ğŸ´ ğŸ ğŸ‘ ğŸ ğŸ“ ğŸ”
# ğŸ¤ ğŸ£ ğŸ¥ ğŸ¦ ğŸ§ ğŸ˜ ğŸª ğŸ« ğŸ— ğŸ– ğŸ· ğŸ½ ğŸ• ğŸ© ğŸ¶ ğŸº ğŸ» ğŸ¨ ğŸ¼ ğŸµ ğŸ™ˆ ğŸ™‰
# ğŸ™Š ğŸ’ ğŸ‰ ğŸ² ğŸŠ ğŸ ğŸ¢ ğŸ¸ ğŸ‹ ğŸ³ ğŸ¬ ğŸ™ ğŸŸ ğŸ  ğŸ¡ ğŸš ğŸŒ ğŸ› ğŸœ ğŸ ğŸ ğŸ¾
#
# ğŸŒ± ğŸŒ² ğŸŒ³ ğŸŒ´ ğŸŒµ ğŸŒ· ğŸŒ¸ ğŸŒ¹ ğŸŒº ğŸŒ» ğŸŒ¼ ğŸ’ ğŸŒ¾ ğŸŒ¿ ğŸ€ ğŸ ğŸ‚ ğŸƒ ğŸ„ ğŸŒ°
#
# ğŸ‘¦ ğŸ‘§ ğŸ‘¨ ğŸ‘© ğŸ‘® ğŸ‘° ğŸ‘± ğŸ‘² ğŸ‘³ ğŸ‘´ ğŸ‘µ ğŸ‘¶ ğŸ‘· ğŸ‘¸ ğŸ’‚ ğŸ‘¼ ğŸ… ğŸ™‡
# ğŸ’ ğŸ™… ğŸ™† ğŸ™‹ ğŸ™ ğŸ™ ğŸ’† ğŸ’‡ ğŸ‘ª ğŸ‘« ğŸ‘¬ ğŸ‘­ ğŸ‘¯ ğŸ’‘ ğŸ’ ğŸ™‡
#
# ğŸ’… ğŸ‘‚ ğŸ‘ƒ ğŸ‘‹ ğŸ‘ ğŸ‘ â˜ ğŸ‘† ğŸ‘‡ ğŸ‘ˆ ğŸ‘‰ ğŸ‘Œ âœŒ ğŸ‘Š âœŠ âœ‹ ğŸ’ª ğŸ‘ ğŸ™Œ ğŸ‘ ğŸ™
# ğŸ‘‹ ğŸ‘ ğŸ‘ â˜ï¸ ğŸ‘† ğŸ‘‡ ğŸ‘ˆ ğŸ‘‰ ğŸ‘Œ âœŒï¸ ğŸ‘Š âœŠ âœ‹ ğŸ’ª ğŸ‘ ğŸ™Œ ğŸ‘ ğŸ™ ğŸ‘€ ğŸ‘„ ğŸ’‹ ğŸ‘…

class Pacman
  class Piece
    def self.dequeue_id
      @current_id ||= 0
      @current_id += 1
    end

    def self.for(char)
      each { |piece| return piece if piece.for? char }
      raise "Couldn't find a piece for: #{char.inspect}"
    end

    def self.all
      @all ||= []
    end

    def self.each(&block)
      all.each &block
    end

    def self.create(type, simple_token, fancy_tokens, &block)
      # normalize
      fancy_tokens = Array fancy_tokens

      # all pieces get the predicate
      define_method("#{type}?") { false }

      # metaprogram in the superclass to support overriding
      default_overrides = Class.new self do
        define_singleton_method :for? do |matcher|
          type == matcher || simple_token == matcher || fancy_tokens.include?(matcher)
        end

        define_method("#{type}?")    { true }
        define_method(:simple_token) { simple_token }
        define_method(:fancy_token)  { |i=0| fancy_tokens.rotate(i).first }
        define_method(:inspect)      { "#<Piece:#{id.inspect}:#{fancy_tokens.first}>" }
      end

      # the actual class
      klass = Class.new default_overrides do
        const_set :DefaultOverrides, default_overrides
        class_eval &block if block
      end

      # track the pieces
      all << klass
      klass
    end

    attr_accessor :id

    def initialize(id: Piece.dequeue_id)
      self.id = id
    end

    def ==(piece)
      id == piece.id
    end

    def desired_move(board)
      nil # dont move this piece
    end

    def tick
      dup.tock
    end

    def tock
      self # no op, subclasses can override
    end

    def barrier?
      false
    end

    def ghost?
      false
    end

    Empty = Piece.create :empty, ' ', ' '

    Gate = Piece.create :gate, '=', 'â€•' do
      def barrier?
        true
      end
    end

    # â˜­\e[0m"
    # â–£\e[0m"
    #  âƒ\e[0m"
    # å³\e[0m"
    # âœš\e[0m"
    # âŒ—\e[0m"
    # âœ›\e[0m"
    # âœœ\e[0m" # pretty good
    Wall = Piece.create :wall,  'W', "\e[44;30mâœ§\e[0m" do
      def barrier?
        true
      end
    end

    # scarier ones:, ğŸ”¥ ğŸ˜± ğŸ‘¹ ğŸ˜ˆ ğŸ‘¾ ğŸ‘» other animals: ğŸ› ğŸ ğŸ£ ğŸ¢ ğŸ¶

    module Ghost
      def self.<<(klass)
        class << klass
          attr_accessor :initial_wait
        end
        klass.__send__ :include, self
      end

      attr_accessor :strategy_time, :strategy

      def initialize(strategy: :mellow, initial_wait: self.class.initial_wait, **keyrest)
        self.strategy      = :mellow
        self.strategy_time = initial_wait
        super **keyrest
      end

      def ghost?
        true
      end

      def mellow?
        strategy == :mellow
      end

      def jail?
        strategy == :jail
      end

      def tock
        self.strategy_time -= 1
        if strategy_time < 0
          self.strategy_time += 100
          self.strategy = :attack
        end
        super
      end

      def go_directly_to_jail
        self.strategy = :jail
        self.strategy_time = 100
      end

      def desired_move(board)
        return nil if mellow?
        if jail?
          next_step_on_shortest_path_to(
            board, self, board.jail
          )
        else
          next_step_on_shortest_path_to(
            board, self, board.pacman
          )
        end
      end

      def next_step_on_shortest_path_to(board, from, to)
        map = board.each_row.map do |row|
          row.map do |pieces|
            meaning = pieces.each.to_a.map do |piece|
              if piece.wall? || piece.ghost?
                :blocked
              elsif piece == to
                :pacman
              else
                nil
              end
            end
            meaning.compact.first || :available
          end
        end

        seen       = Hash.new
        check_next = []
        check_next << [board.to_location(from), nil]
        result     = nil
        until result
          break nil if check_next.empty?  # we can't get to pacman, chill for a bit

          to_check, parent = check_next.shift
          seen[to_check] = parent
          y, x = to_check

          [[y-1,x], [y+1, x], [y, x-1], [y, x+1]].each do |adjacent|
            newy, newx = adjacent
            if seen.key?(adjacent) || newy < 0 || newx < 0 || newy >= map.length || newx >= map[newy].length || map[newy][newx] == :blocked
              # no op
            elsif map[newy][newx] == :pacman
              check_next << [adjacent, to_check]
              seen[adjacent] = to_check
              result = adjacent
              while seen[seen[result]]
                result = seen[result]
                map[result[0]][result[1]] = :path
              end
              map[result[0]][result[1]] = :move
            else
              check_next << [adjacent, to_check]
            end
          end
        end

        result
      end
    end


        # targety, targetx = board.to_location(board.jail)
        # actualy, actualx = board.to_location(self)
        # [[actualy-1, actualx],
        #  [actualy+1, actualx],
        #  [actualy,   actualx-1],
        #  [actualy,   actualx+1],
        # ].reject { |loc| board.pieces_on(loc).any? &:wall? }
        #  .min_by { |y, x|
        #    ydist = (y-targety).abs
        #    xdist = (x-targetx).abs
        #    Math.sqrt(ydist**2 + xdist**2)
        #  }
    # red aka shadow
    Blinky = Piece.create :blinky, 'r', 'ğŸ·' do
      Ghost << self
      self.initial_wait = 0
    end

    # pink aka speedy
    Pinky = Piece.create :ghost, 'y', 'ğŸ™' do
      Ghost << self
      self.initial_wait = 0
    end

    # cyan aka bashful
    Inky = Piece.create :ghost, 'i', 'ğŸ³' do
      Ghost << self
      self.initial_wait = 30
    end

    # orange aka pokey
    Clyde = Piece.create :ghost, 'o', 'ğŸŒ' do
      Ghost << self
      self.initial_wait = 90
    end

    Vitamin = Piece.create :vitamin, 'v', ['ğŸ„', ' '] do
      def value
        50
      end
    end

    Food = Piece.create :food, '.', 'â—' do
      def value
        10
      end
    end

    Jail = Piece.create :jail, 'J', ' '

# Fruit:
# Cherry: 100 points.
# Strawberry: 300 points
# Orange: 500 points
# Apple: 700 points
# Melon: 1000 points
# Galxian Boss: 2000 points
# Bell: 3000 points
# Key: 5000 points

    Pacman = Piece.create :pacman, 'p', 'ğŸ˜œ' do
      const_set :TOKENS, {
        dead:      ['ğŸ˜²'],
        roid_rage: ['ğŸ˜¡'],
        # hungry:    %w[ğŸ˜„ ğŸ˜ ],
        hungry:    %w[ğŸ˜œ ğŸ˜› ğŸ˜ ],
      }.freeze

      attr_accessor :status, :num_lives, :direction, :score, :tokens, :roid_level, :next_roid_bonus

      def initialize(status: :hungry, num_lives: 3, direction: :up, score: 0, tokens: Pacman::TOKENS, roid_level: 0, next_roid_bonus: 200, **kwrest)
        super **kwrest
        self.score           = score
        self.status          = status
        self.num_lives       = num_lives
        self.direction       = direction
        self.tokens          = tokens
        self.roid_level      = roid_level
        self.next_roid_bonus = next_roid_bonus
      end

      def die!
        self.status = :dead
      end

      def dead?
        status == :dead
      end

      def roid_rage!
        self.roid_level += 40
        self.status = :roid_rage
      end

      def roid_rage?
        status == :roid_rage
      end

      def hungry!
        self.roid_level      = 0
        self.next_roid_bonus = 200
        self.status          = :hungry
      end

      def hungry?
        status == :hungry
      end

      def fancy_token(i=0)
        tokens[status].rotate(i).first
      end

      def game_over?
        status == :dead && num_lives.zero?
      end

      def face(direction)
        self.direction = direction
      end

      def desired_move(board)
        crnty, crntx = board.to_location(self)
        newy,  newx  = crnty, crntx
        case direction
        when :up    then newy -= 1
        when :right then newx += 1
        when :down  then newy += 1
        when :left  then newx -= 1
        else raise "Unknown direction: #{direction.inspect}"
        end

        if board.pieces_on([newy, newx]).any?(&:barrier?)
          [crnty, crntx]
        else
          [newy, newx]
        end
      end

      def eat(edible)
        if edible.vitamin?
          roid_rage!
          self.score += edible.value
        elsif edible.ghost?
          self.score += next_roid_bonus
          self.next_roid_bonus *= 2
        else
          self.score += edible.value
        end
      end

      def tock
        if roid_rage?
          self.roid_level -= 1
          hungry! if roid_level <= 0
        end
        super
      end
    end
  end
end
